<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<h1 id="title-cleaner">Code Cleaner</h1>

<style>
  :root{
    --bg:#071227;
    --muted:#93a2b8;
    --accent:#7dd3fc;
    --green:#00ff00;
    --red:#ff2e2e;
    --gold:#ffd700;
  }
  html,body{
    height:100%;margin:0;
    font-family:Inter,system-ui,Arial;
    background:linear-gradient(180deg,#041025 0%,#071227 100%);
    color:#fff;
  }
  .wrap{
    max-width:1100px;margin:20px auto;padding:18px;
    border-radius:12px;
    background:rgba(255,255,255,0.03);
    box-shadow:0 6px 30px rgba(0,0,0,0.5);
  }
h1 {
  text-align: center;
  margin: 0 0 8px;
  font-size: 22px;
  font-weight: 800;
  background: linear-gradient(to bottom, #FFFF00 50%, #00FF00 50%);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  color: transparent;
}
  p.lead{text-align:center;color:var(--muted);margin:0 0 14px}
  .container{display:flex;flex-wrap:wrap;gap:18px}
  textarea, pre{
    width:100%;min-height:320px;
    background:#071126;
    color:var(--green);
    border:1px solid rgba(255,255,255,0.12);
    border-radius:10px;
    padding:14px;font-family:monospace;font-size:13px;
    resize:vertical;box-sizing:border-box;
    transition:0.3s;
    overflow:auto;white-space:pre-wrap;
  }
  @media(min-width:900px){textarea, pre{width:calc(50% - 9px)}}
  pre#output{color:var(--gold);} /* fallback */
  textarea:focus{
    outline:none;
    border-color:var(--gold);
    box-shadow:0 0 10px var(--accent);
  }
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  button{
    border:none;color:#fff;
    padding:10px 14px;border-radius:8px;
    cursor:pointer;font-weight:700;
  }
  #sanitize{background:#00b300;}
  #clear{background:#cc0000;}
  #paste{background:#ffcc00;color:#000;}
  #copy{background:#00bfff;}
  #download{background:#9933ff;}
  .opts{
    display:flex;flex-direction:column;gap:6px;
    margin-top:14px;padding:10px;
    background:rgba(255,255,255,0.02);
    border-radius:8px;
  }
  input[type="checkbox"]{accent-color:var(--green);transform:scale(1.2);}
  label{font-size:14px;color:var(--gold)}
  .footer{text-align:center;color:var(--muted);margin-top:14px;font-size:13px}
  .counts {
    color: #00ff00;
    font-weight: 700;
    text-shadow: 0 0 6px #00ff00;
  }

  /* output classes */
  pre#output .method { color: var(--green); font-weight: 900; }
  pre#output .header-key { font-weight: 900; }
  pre#output .redacted { color: var(--gold); font-weight: 900; text-shadow: 0 0 6px var(--gold); }
</style>
</head>
<body>
<div class="wrap">

  <div class="container">
    <textarea id="input" placeholder="Paste code or plain text here..."></textarea>
    <pre id="output" placeholder="Sanitized output..." readonly></pre>
  </div>

  <div class="controls">
    <button id="sanitize">Sanitize</button>
    <button id="clear">Clear</button>
    <button id="paste">Paste</button>
    <button id="copy">Copy Output</button>
    <button id="download">Download .txt</button>
  </div>

  <div class="opts">
    <label><input type="checkbox" id="opt-urls" checked> Remove full URLs (outside preserved method paths)</label>
    <label><input type="checkbox" id="opt-provider" checked> Provider token prefixes (xoxb_, ghp_, sk_live_, AKIA...)</label>
    <label><input type="checkbox" id="opt-generic" checked> Generic tokens (JWTs, long secrets)</label>
    <label><input type="checkbox" id="opt-kv" checked> Key=value / key: value / "key": "value" redaction (values only)</label>
  </div>

  <div class="footer">Removed: <span id="removed" class="counts">0</span></div>
</div>

<script>
(function(){
  const inEl = document.getElementById('input');
  const outEl = document.getElementById('output');
  const removedEl = document.getElementById('removed');

  function escapeHtml(t){ return String(t).replace(/[&<>"']/g,ch=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch])); }

  // ---------- decoding helpers ----------
  function tryBase64Decode(s){
    try{
      const cleaned = String(s).replace(/[\r\n\s]+/g,'');
      if(!/^[A-Za-z0-9+/=]+$/.test(cleaned)) return null;
      const dec = atob(cleaned);
      if(/[\x20-\x7E]{4,}/.test(dec)) return dec;
    }catch(e){}
    return null;
  }

  function decodePercentSequences(text){
    return text.replace(/%(?:[0-9A-Fa-f]{2})+/g, m => {
      try{ return decodeURIComponent(m); } catch(e){ return m; }
    });
  }

  function decodeLongBase64Tokens(text){
    return text.replace(/\b([A-Za-z0-9+/=]{40,})\b/g, (m) => {
      const dec = tryBase64Decode(m);
      if(!dec) return m;
      return `${m}\n[DECODED_BASE64_START]\n${dec}\n[DECODED_BASE64_END]`;
    });
  }

  function tryDecodeAll(text){
    if(!text) return text;
    let t = String(text);
    t = decodePercentSequences(t);
    t = t.split('\n').map(line => {
      if(line.includes('%') || line.includes('+')){
        try{ return decodeURIComponent(line); } catch(e){ return line; }
      }
      return line;
    }).join('\n');
    t = decodeLongBase64Tokens(t);
    return t;
  }
  // ---------- end decoding helpers ----------

  // provider/prefix patterns
  const prefixPatterns=[
    {re:/\bxox[bp]-[A-Za-z0-9-_.]{6,}/gi,tag:'SLACK'},
    {re:/\bghp_[A-Za-z0-9_]{6,}/gi,tag:'GITHUB'},
    {re:/\bglpat-[A-Za-z0-9]{6,}/gi,tag:'GITLAB'},
    {re:/\bsk_live_[A-Za-z0-9]{6,}/gi,tag:'STRIPE'},
    {re:/\bsk_test_[A-Za-z0-9]{6,}/gi,tag:'STRIPE'},
    {re:/\bAKIA[0-9A-Z]{8,}\b/g,tag:'AWS'},
    {re:/\btoken\s+[A-Za-z0-9._-]{6,}/gi,tag:'TOKEN'},
    {re:/\bBearer\s+[A-Za-z0-9\-_.=]+/gi,tag:'BEARER'},
    {re:/Authorization:\s*["']?([A-Za-z0-9\-_.=]+)["']?/gi,tag:'AUTH'}
  ];

  const RE = {
    method_path: /(^|\n)(\s*)(GET|POST|PUT|DELETE|HEAD|OPTIONS|TRACE|PATCH)\s+([^\s\n\r]+)/gi,
    query_param_value: /([?&])([^=&#\s]+)=([^&#\s]*)/g,
    basic_auth: /https?:\/\/([^\/\s:]+):([^\/\s@]+)@/gi,
    url_with_query: /https?:\/\/[^\s"'<>?#]+\?([^\s"'<>#]*)/gi,
    url_no_query: /https?:\/\/[^\s"'<>]+/gi,
    key_assignment: /\b([A-Za-z0-9_.-]{2,60})\b(\s*[:=]\s*)(["']?)([^"'`;\n\r,}]{1,500})\3/gi,
    jwt: /\b[A-Za-z0-9-_]{10,}\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\b/g,
    long_secret: /\b[A-Za-z0-9+/=_\-.]{40,}\b/g,
    email: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g
  };

  function redactQueryValues(str, counter){
    return str.replace(RE.query_param_value, (m, sep, name, val) => {
      if(val && val.length > 0) counter.count++;
      return `${sep}${name}=[REDACTED]`;
    });
  }

  function sanitizeRaw(input, opts){
    let text = input || '';
    text = tryDecodeAll(text); // ðŸ”¹ decode before sanitize
    let removed = 0;
    if(!text) return { text:'', removed:0 };

    text = text.replace(RE.method_path, (m, preNl, ws, method, path) => {
      const newPath = redactQueryValues(path, { count: 0 });
      newPath.replace(RE.query_param_value, (mm, s, n, v) => { if(v && v.length>0) removed++; return mm; });
      const finalPath = newPath.replace(RE.query_param_value, (mm, s, n, v)=> `${s}${n}=[REDACTED]`);
      return preNl + ws + method + ' ' + finalPath;
    });

    if(opts.urls){
      text = text.replace(RE.basic_auth, ()=>{ removed++; return 'https://[REDACTED_BASIC_AUTH@]'; });
      text = text.replace(RE.url_with_query, (m) => {
        const qIndex = m.indexOf('?');
        if(qIndex < 0) { removed++; return '[REDACTED_URL]'; }
        const b = m.slice(0, qIndex);
        const q = m.slice(qIndex + 1);
        const rq = q.replace(RE.query_param_value, (mm, sep, name, val) => { if(val && val.length>0) removed++; return sep + name + '=[REDACTED]'; });
        return b + '?' + rq;
      });
      text = text.replace(RE.url_no_query, ()=>{ removed++; return '[REDACTED_URL]'; });
    }

    if(opts.kv){
      text = text.replace(RE.key_assignment, (match, key, sep, q, val) => {
        if(/^\s*https?:\/\//i.test(val) || /\/{1,}/.test(val)) return match;
        removed++;
        return `${key}${sep}${q || ''}[REDACTED]${q || ''}`;
      });
    }

    if(opts.prefixes){
      prefixPatterns.forEach(it=>{
        text = text.replace(it.re, (m)=>{ removed++; return `[REDACTED_${it.tag}]`; });
      });
    }

    if(opts.generic){
      text = text.replace(RE.jwt, ()=>{ removed++; return '[REDACTED_JWT]'; });
      text = text.replace(RE.long_secret, (m)=>{ if(m.indexOf('/')>=0) return m; removed++; return '[REDACTED_LONG]'; });
    }

    text = text.replace(RE.email, ()=>{ removed++; return '[REDACTED_EMAIL]'; });

    if(opts.urls){
      text = text.replace(/(^|\n)(\s*)(Host|Origin|Referer)\s*:\s*([^\n\r]+)/gi, (m, pre, ws, key, val) => {
        removed++; return `${pre}${ws}${key}: [REDACTED_URL]`;
      });
    }

    if(opts.urls){
      text = text.replace(RE.query_param_value, (m, sep, name, val) => {
        if(val && val.length>0) removed++;
        return `${sep}${name}=[REDACTED]`;
      });
    }

    return { text, removed };
  }

  function getOpts(){
    return {
      urls: document.getElementById('opt-urls').checked,
      prefixes: document.getElementById('opt-provider').checked,
      generic: document.getElementById('opt-generic').checked,
      kv: document.getElementById('opt-kv').checked
    };
  }

  const palette = ["#00FF00", "#FFFF00", "#FF0000", "#00BFFF", "#00FFFF"];
  const headerColorMap = {};
  let paletteIndex = 0;
  function getHeaderColor(key){
    const k = String(key).toLowerCase();
    if(headerColorMap[k]) return headerColorMap[k];
    const c = palette[paletteIndex % palette.length];
    headerColorMap[k] = c;
    paletteIndex++;
    return c;
  }

  let phCounter = 0;
  let phMap = {};
  function resetPlaceholders(){ phCounter = 0; phMap = {}; }
  function makePH(html){
    const ph = `__PH_${Date.now().toString(36)}_${phCounter}__`;
    phMap[ph] = html;
    phCounter++;
    return ph;
  }

  function colorizeSanitized(redactedText){
    resetPlaceholders();
    let working = redactedText;
    working = working.replace(/(^|\n)(\s*)(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS|TRACE)\b/ig,
      (m, pre, ws, method) => `${pre}${ws}${makePH(`<span class="method">${escapeHtml(method)}</span>`)}`);
    working = working.replace(/(^|\n)(\s*)(["']?)([A-Za-z0-9\-\._]{1,200})\3(\s*:\s*)/g, (m, lead, ws, q, key, sep) => {
      const color = getHeaderColor(key);
      const keyHtml = `<span class="header-key" style="color:${color};">${escapeHtml(key)}</span>`;
      return `${lead}${ws}${q || ''}${makePH(keyHtml)}${q || ''}${sep}`;
    });
    working = working.replace(/\[REDACTED_[A-Z0-9_]+\]/g, m => makePH(`<span class="redacted">${escapeHtml(m)}</span>`));
    working = working.replace(/(Authorization\s*:\s*)(["']?)[A-Za-z0-9\-_.=\[\]]+\2/ig, (m, pfx) => `${pfx}${makePH('<span class="redacted">[REDACTED]</span>')}`);
    let escaped = escapeHtml(working);
    for(const ph in phMap) escaped = escaped.split(ph).join(phMap[ph]);
    return escaped;
  }

  document.getElementById('sanitize').addEventListener('click', ()=>{
    const input = inEl.value;
    const opts = getOpts();
    const result = sanitizeRaw(input, opts);
    removedEl.textContent = result.removed;
    outEl.innerHTML = colorizeSanitized(result.text);
  });

  document.getElementById('clear').addEventListener('click', ()=>{
    inEl.value = '';
    outEl.innerHTML = '';
    removedEl.textContent = '0';
    for(const k in headerColorMap) delete headerColorMap[k];
    paletteIndex = 0;
    resetPlaceholders();
  });

  document.getElementById('paste').addEventListener('click', async ()=>{
    try{ inEl.value = await navigator.clipboard.readText(); } catch(e){ alert('Clipboard denied'); }
  });

  document.getElementById('copy').addEventListener('click', ()=>{
    navigator.clipboard.writeText(outEl.innerText).catch(()=>{});
  });

  document.getElementById('download').addEventListener('click', ()=>{
    const blob = new Blob([outEl.innerText], { type:'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sanitized.txt';
    a.click();
    URL.revokeObjectURL(a.href);
  });
})();
</script>

</body>
</html>
